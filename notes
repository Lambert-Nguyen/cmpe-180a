02/20/25 Lecture
We had a great lecture last night with a lot of great questions and great participation from many students! lets keep the great work for the upcoming classes.

We covered topics like:

Class definition & implementation
default arguments
const methods
iterartors forward, backward, const
When to pass by reference or value
when to return by value or reference
Time and space complexity
Arithmetic and geometric series
Class vs Object: representation of an object in memory
The this pointer and its justification
We also reviewed ways to have a function return multiple values or items. We stressed the importance of not using C type strings and instead using C++ string class

----------------------------------------------------------------
03/06/2025 Lecture:

Operator overload:

Binary operators:
a+b
a*b
a-b
:
;
---> member function

Unary operators:
!a
-a
--a
a++
a[i]
---> function??

Binary operators:
cout<<a;
cin>>b;
---> class function??

Friend function:
class XYPoint {
    friend operator <<(...);
    XYPoint operator+(arg)
    *****Make use of "this" pointer****
    bool operator!(){}
}

------------------------
Linked list
shallow copy vs deep copy
time complexity
----------------------------------------------------------------
03/13/2025:

midterm will be 5 coding questions, covering C++ classes, overloading, template

f(vector<int> v, size){
    for (i=0;i<size;i++){
        v[i] = i*i;
    }
}

The problem for the above function is we should not passing the "size" since there will be inconsistance in vector and the "sie that being passed"
The correct way should be passing the vector only, using vector size function and use pushback for inserting data.

### We should pass by reference and use const if you don't want the variable being changed ###
(recursion is not the best solution for factorio)
Recursion -> factorio

General case: f(n) = f(n=1)*n
Base case: f(0)=f(1)=1, f(2)=2f(1)

*** Check for 2 things: generalcase + base case when programming ***

Backtracking

Types of recursion:
-Direct
-Indirect: f->B->f or f->B->A->f
-tail recursion: when the function is called at the end of the function
    f(){
        INT 1
        INT 2
        INT 3
        f(4)
        } --> tail recursion
